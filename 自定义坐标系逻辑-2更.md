
# 自定义坐标系与位姿获取逻辑优化 🚀 

根据提供的 `Tracking.h` 文件内容，以下是对自定义坐标系和位姿获取逻辑的分析
## 📌 IPoseObserver 接口 

- ✅ **接口定义**：`IPoseObserver` 接口已定义在 `Tracking.h` 中
- 📜 **方法签名**：`OnPoseUpdated(const Sophus::SE3f& T_custom_world_camera, double timestamp)` 正确接收自定义世界坐标系下的相机位姿 

## 👥 位姿观察者管理 

- 🛠 **注册与注销**：Tracking 类中
- `void RegisterPoseObserver(IPoseObserver* pObserver)`：用于注册观察者。
- `void UnregisterPoseObserver(IPoseObserver* pObserver)`：用于取消注册观察者。
- 📚 **观察者存储**：通过 `std::vector<IPoseObserver*> mvpPoseObservers` 维护观察者列表。
- 🔒 **线程安全**：`std::mutex mMutexPoseAccess` 用于保护观察者列表的访问。

## 🌍 自定义世界坐标系变换 
- 🔧 **设置变换**：`void SetCustomWorldTransform(const Sophus::SE3f& T_custom_orb)` 用于设置自定义坐标系相对于 ORB-SLAM 坐标系的变换。
- 💾 **存储变换**：`Sophus::SE3f mT_custom_orb` 用于保存该变换。  

## 🔍 详细解释与优化建议 
### 当前帧位姿获取 🔄
- **线程**：`Tracking` 线程中的 `Track()` 方法负责计算当前帧位姿 `mCurrentFrame.mTcw`（即 `T_orb_c`）。
- Tracking 类中有一个方法用于设置自定义变换：void SetCustomWorldTransform(const Sophus::SE3f& T_custom_orb);
- **通知时机**：在 `Track()` 方法末尾，当 `mCurrentFrame.mTcw` 确定后，执行以下步骤：
1. 将 `T_orb_c` 转换为自定义世界坐标系下的位姿 `T_custom_world_camera`（通过 `mT_custom_orb` 变换）。
2. 使用 `OnPoseUpdated` 通知所有注册的观察者。  

## ❓疑问

### GrabImage... 方法返回的位姿是 Tracking 线程的最终位姿吗？

> [!question] 
>  Tracking 类提供了几个 GrabImage... 方法（如 GrabImageMonocular, GrabImageStereo, GrabImageRGBD）。这些方法内部会调用 Track () 来处理图像并更新 mCurrentFrame. mTcw。这些 GrabImage... 方法通常会返回 mCurrentFrame. GetPoseInverse ()，即 mCurrentFrame. mTwc。


是的，对于当前正在处理的这一帧图像来说，`GrabImage...`（例如 `GrabImageMonocular`）返回的位姿是 **Tracking 线程**为这一帧计算出来的“最终”位姿。
## 过程分析
### 1. 入口
当调用 `Sophus::SE3f System::TrackMonocular(const cv::Mat &im, const double &tamp, const vector<IMU::Point>& vImuMeas, string filename)`（或其他传感器的 `TrackXXX` 方法）时，内部会调用 `Tracking::GrabImageMonocular(...)`。
![image.png|500](https://bu.dusays.com/2025/06/05/68419d9a23f14.png)

### 2. `Tracking::GrabImageMonocular(...)`
![image.png|500](https://bu.dusays.com/2025/06/05/68419ef702d7a.png)

- **预处理**：对输入图像进行预处理（例如灰度化）。
- **封装 Frame 对象**：将图像和时间戳封装到 `Frame` 对象 `mCurrentFrame` 中。
- **调用核心方法**：调用 `Track()` 方法：`Track()`。
- **更新位姿**：`Track()` 方法执行完毕后，`mCurrentFrame.mTcw`（相机到世界坐标系的变换）会被更新为当前帧的估计位姿。
- **返回位姿**：`GrabImageMonocular` 方法最后返回 `mCurrentFrame.GetPoseInverse()`，即 `mCurrentFrame.mTwc`（世界到相机坐标系的变换）。

### 3. `Tracking::Track()` 内部
`Track()` 方法是跟踪的核心，根据系统当前状态执行一系列操作来估计 `mCurrentFrame.mTcw`：
![image.png|500](https://bu.dusays.com/2025/06/05/68419fb998cf0.png)

1. **IMU 预积分与状态预测**（如果使用 IMU）：
   - 利用 IMU 数据预测当前帧的初始位姿。
2. **特征提取**：
   - 在当前帧上提取 ORB 特征点。
3. **状态判断与跟踪**：
   - **初始化**：如果系统未初始化，则尝试进行单目/双目/RGBD 初始化。
   - **运动模型跟踪 (`TrackWithMotionModel`)**：
     - 如果上一帧跟踪成功，基于恒速运动模型预测当前帧位姿，并与上一帧的地图点进行匹配优化。
   - **参考关键帧跟踪 (`TrackReferenceKeyFrame`)**：
     - 如果运动模型跟踪失败或地图点较少，尝试与最近的关键帧进行匹配来定位。
   - **局部地图跟踪 (`TrackLocalMap`)**：
     - 这是非常关键的一步。系统获取当前帧的局部地图（由附近的共视关键帧及其观测到的地图点组成）。
     - 将当前帧的特征点与这些局部地图点进行匹配，通过优化最小化重投影误差，从而优化当前帧的位姿 `mCurrentFrame.mTcw`。
     - 这一步使得 Tracking 线程能够利用到 LocalMapping 线程优化过的地图信息。
   - **重定位 (`Relocalization`)**：
     - 如果跟踪完全丢失，则通过词袋模型在整个地图中进行重定位。
4. **创建新关键帧 (`CreateNewKeyFrame`)**：
   - 根据一系列规则判断当前帧是否应成为新的关键帧。如果是关键帧，它会被发送给 LocalMapping 线程进行进一步处理。

### 4. 总结
`GrabImage...` 返回的位姿 `mCurrentFrame.mTwc`（其逆为 `mCurrentFrame.mTcw`）是 **Tracking 线程**在处理完当前输入图像后，综合以下步骤得到的位姿：
- 运动模型预测
- 与参考帧匹配
- 利用局部地图（`TrackLocalMap`）进行优化
因此，它是 **Tracking 线程对当前帧位姿的最佳估计**。