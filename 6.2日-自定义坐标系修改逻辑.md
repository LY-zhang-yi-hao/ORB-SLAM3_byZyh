---
UID: 202506030956
alias:
banner: 99-Attachment/banner/蓝山背景.jpg
```js quickadd
const suggester = await this.quickAddApi.suggester(["开心😀", "低落😐", "疲惫😪","爽😎","平静😶"], ["😀", "😐", "😪", "😎", "😶"])
return `banner_icon: ${suggester}`;
```
Banner style: Solid
cssclass: mynote,noyaml
---
> [!blank]
> [timeline{{DATE:DDD}}::timeline]
```ad-flex
(Weather::not found ☀️   24°C ↓9km/h)
> [!infobox|noicon]- 🔖 当天创建的文件
> ```dataviewjs
const filename=dv.current().file.name;
dv.list(dv.pages().where(p => p.file.cday.toISODate() === filename).sort(p => p.file.ctime, 'desc').file.link)
>```
```

---

# 📜 **源码更改和逻辑详解：自定义位姿观察者**

为了实现实时获取相机在自定义世界坐标系下的位姿并通过回调函数输出的需求，我们对 ORB-SLAM3 的源码进行了以下关键修改。这些修改主要集中在定义观察者接口、在 `Tracking` 类中集成观察者功能，并在 `mono_euroc.cc` 中实现具体使用。

---

## **1. 定义位姿观察者接口 (`IPoseObserver`)**

### **文件**: `include/Tracking.h`
- **目的**：定义了一个抽象接口，任何希望接收位姿更新的类都必须继承它并实现 `OnRealTimePoseUpdated` 方法。

### **更改**:
我们在 `Tracking.h` 中定义了一个纯虚接口类 `IPoseObserver`，用于规范位姿更新的观察者行为。

```cpp
// 在 ORB_SLAM3 命名空间内
namespace ORB_SLAM3 {

class IPoseObserver {
public:
    virtual ~IPoseObserver() = default; // 虚析构函数，确保派生类对象能正确销毁
    // 纯虚函数，当位姿更新时被调用
    // 参数 T_custom_world_camera 是相机在自定义世界坐标系下的位姿
    virtual void OnRealTimePoseUpdated(const Sophus::SE3f& T_custom_world_camera) = 0;
};

} // namespace ORB_SLAM3
```

### **逻辑**:
- **接口契约**: `IPoseObserver` 定义了一个抽象接口。任何希望接收位姿更新的类都必须继承它并实现 `OnRealTimePoseUpdated` 方法。这种设计遵循了面向对象编程中的**依赖倒置原则**。
- **解耦设计**: 通过接口，`Tracking` 类与具体观察者实现（如 `MyPosePrinter`）解耦。`Tracking` 无需关心观察者的具体类型，只需确保其符合 `IPoseObserver` 接口即可。
- **位姿表示**: 参数 `T_custom_world_camera` 使用 `Sophus::SE3f` 表示，这是一个轻量级库中用于描述三维刚体变换的类型，包含旋转（`SO3f`）和平移（`Eigen::Vector3f`）。`SE3f` 的 `f` 表示浮点数精度。

---

## **2. 在 `Tracking` 类中集成位姿观察者**

### **文件**: `include/Tracking.h` 和 `src/Tracking.cc`

### **更改（`include/Tracking.h`）**:

#### **新增成员变量**:
在 `Tracking` 类的 `private` 部分添加了以下成员变量：

```cpp
// 在 Tracking 类的 private 部分
ORB_SLAM3::IPoseObserver* mpPoseObserver; // 指向位姿观察者的指针
std::mutex mMutexPoseObserver;            // 用于保护对 mpPoseObserver 和 mT_custom_orb 的访问 (更名为 mMutexPoseObserver 以清晰表明其保护范围)
Sophus::SE3f mT_custom_orb;               // 存储从 ORB-SLAM 世界坐标系到自定义世界坐标系的转换关系 (T_Custom,ORB)
```

- `mpPoseObserver`: 存储观察者对象的指针，初始为空。
- `mMutexPoseObserver`: 互斥锁，确保多线程环境下对 `mpPoseObserver` 和 `mT_custom_orb` 的访问是线程安全的。
- **`mT_custom_orb`**: 这个成员变量至关重要。它存储的是从 **ORB-SLAM 世界坐标系** 转换到 **用户自定义世界坐标系** 的变换。我们将其表示为 \( T_{\text{Custom,ORB}} \)。

#### **注册观察者函数 (`RegisterPoseObserver`)**:
在 `public` 部分添加了 `RegisterPoseObserver` 函数，用于外部注册观察者。为避免链接器错误，将其定义为 `inline` 函数：

```cpp
// 在 Tracking 类的 public 部分
inline void RegisterPoseObserver(IPoseObserver* pObserver)
{
    std::unique_lock<std::mutex> lock(mMutexPoseObserver); // 加锁以保证线程安全
    mpPoseObserver = pObserver;                          // 将传入的观察者指针赋值给成员变量
    if (mpPoseObserver) {
        std::cout << "自定义位姿观察者已注册。" << std::endl;  // 日志确认注册成功
    } else {
        std::cout << "自定义位姿观察者已注销。" << std::endl;
    }
}
```

#### **设置坐标系转换函数 (`SetCustomWorldTransform`)**:
添加了 `SetCustomWorldTransform` 函数，用于设置自定义世界坐标系与 ORB-SLAM 世界坐标系之间的转换关系。
**关键点**：此函数期望接收的参数 `T_c_o` (原 `T_custom_orb`) 就是 $( T_{\text{Custom,ORB}} )$，即从 ORB 世界到自定义世界的变换。

![image.png|500](https://bu.dusays.com/2025/06/03/683ea43da9223.png)
```cpp
// 在 Tracking 类的 public 部分
// 参数名 T_custom_from_orb 更清晰地表明了变换的方向：从ORB世界到自定义世界
inline void SetCustomWorldTransform(const Sophus::SE3f& T_custom_from_orb) {
    std::unique_lock<std::mutex> lock(mMutexPoseObserver); // 加锁
    mT_custom_orb = T_custom_from_orb;                     // 存储转换关系 T_Custom,ORB
    // 输出变换的平移和旋转（四元数形式）以便调试
    std::cout << "设置的 T_custom_from_orb (mT_custom_orb) 平移: "
              << mT_custom_orb.translation().transpose()
              << " 旋转 (四元数 w,x,y,z): "
              << mT_custom_orb.unit_quaternion().coeffs().transpose() << std::endl;
    std::cout << "自定义位姿转换已设置 (ORB World -> Custom World)。" << std::endl;
}
```
*为了更清晰，参数名从 `T_custom_orb` 改为 `T_custom_from_orb`，以准确反映其代表从ORB世界到自定义世界的变换。*

### **更改（`src/Tracking.cc`）**:

#### **构造函数初始化**:
在 `Tracking` 的构造函数中添加以下代码：

```cpp
// Tracking::Tracking(...) 构造函数内
mpPoseObserver = nullptr; // 初始化观察者指针为空
mT_custom_orb = Sophus::SE3f(); // 初始化为单位变换（无旋转，无平移）
std::cout << "Tracking constructor: mpPoseObserver initialized to nullptr" << std::endl;
std::cout << "Tracking constructor: mT_custom_orb initialized to identity (translation): "
          << mT_custom_orb.translation().transpose() << std::endl;
```
- `Sophus::SE3f()` 默认构造为单位变换，表示初始时自定义坐标系与 ORB-SLAM 世界坐标系重合。

#### **通知观察者**:
在 `Tracking::Track()` 函数中，当跟踪状态 `mState` 为 `OK` 且 `mpPoseObserver` 已注册时，计算并通知位姿：

```cpp
// 在 Track() 函数中，当 mState == OK 时
if (mState == OK) {
    // ... 其他代码 ...

    // 如果注册了位姿观察者，并且当前状态是OK，则通知观察者
    if (mpPoseObserver) {
        std::unique_lock<std::mutex> lock(mMutexPoseObserver); // 加锁保护 mT_custom_orb 和 mpPoseObserver
        // mCurrentFrame.GetPose() 获取的是相机在ORB-SLAM世界坐标系下的位姿 T_ORB,Camera
        // (注意: ORB-SLAM3中 Frame::GetPoseInverse() 返回 Twc，即相机到世界坐标系的变换，
        //  但通常我们讨论“相机位姿”是指相机坐标系到世界坐标系的变换 T_world_camera。
        Sophus::SE3f T_orb_camera = mCurrentFrame.GetPoseInverse(); // 相机在ORB-SLAM世界坐标系下的位姿

        // 计算相机在自定义世界坐标系下的位姿: T_Custom,Camera = T_Custom,ORB * T_ORB,Camera
        Sophus::SE3f T_custom_camera = mT_custom_orb * T_orb_camera;

        mpPoseObserver->OnRealTimePoseUpdated(T_custom_camera); // 调用观察者的回调函数
    }
}
```

### **逻辑**:
- **注册机制**: `RegisterPoseObserver` 允许外部代码传入一个 `IPoseObserver` 对象。
- **坐标系转换**:
    - `mT_custom_orb` 存储 $( T_{\text{Custom,ORB}} )$，即从 **ORB-SLAM 世界坐标系** 到 **自定义世界坐标系** 的变换。
    - `mCurrentFrame.GetPose()` 返回相机在 ORB-SLAM 世界坐标系下的位姿，即 $( T_{\text{ORB,Camera}} )$。
    - 要得到相机在自定义世界坐标系下的位姿 $( T_{\text{Custom,Camera}} )$，计算公式为：
      $[
      T_{\text{Custom,Camera}} = T_{\text{Custom,ORB}} \times T_{\text{ORB,Camera}}
      ]$
      这对应代码中的 `Sophus::SE3f T_custom_camera = mT_custom_orb * T_orb_camera;`。
- **通知流程**: 每次 `Track()` 成功更新位姿后，若观察者已注册：
    1. 获取当前相机在 ORB 世界坐标系下的位姿 $( T_{\text{ORB,Camera}} )$。
    2. 使用 $( mT_{\text{custom\_orb}} )$ 将其直接变换到自定义世界坐标系，得到 $( T_{\text{Custom,Camera}} )$。
    3. 调用观察者的 `OnRealTimePoseUpdated` 方法传递结果。
- **线程安全**: 使用 `std::mutex` 和 `std::unique_lock` 保护共享资源 `mpPoseObserver` 和 `mT_custom_orb`。
- **`inline` 函数**: 将 `RegisterPoseObserver` 和 `SetCustomWorldTransform` 定义为 `inline`，确保它们在头文件中直接可用，避免链接错误。

---

## **3. 在 `mono_euroc.cc` 中使用位姿观察者**

### **文件**: `Examples/Monocular/mono_euroc.cc`

### **更改**:

#### **包含头文件**:
确保包含必要的头文件：

```cpp
#include "System.h"         // ORB_SLAM3::System
#include "Tracking.h"       // ORB_SLAM3::Tracking, ORB_SLAM3::IPoseObserver
#include <sophus/se3.hpp>   // Sophus::SE3f
#include <iostream>         // std::cout
```

#### **实现观察者类 (`MyPosePrinter`)**:
定义一个具体类 `MyPosePrinter`，继承 `ORB_SLAM3::IPoseObserver` 并实现位姿打印功能：

```cpp
// 定义一个具体的位姿观察者类
class MyPosePrinter : public ORB_SLAM3::IPoseObserver {
public:
    void OnRealTimePoseUpdated(const Sophus::SE3f& T_custom_world_camera) override {
        // 提取平移部分并打印相机在自定义坐标系下的位置
        std::cout << "回调: 相机在自定义坐标系下位置 (X,Y,Z): "
                  << T_custom_world_camera.translation().x() << ", "
                  << T_custom_world_camera.translation().y() << ", "
                  << T_custom_world_camera.translation().z() << std::endl;
        // 可选：打印旋转部分 (例如，以四元数形式)
        // const Eigen::Quaternionf q = T_custom_world_camera.unit_quaternion();
        // std::cout << "回调: 相机在自定义坐标系下姿态 (qx,qy,qz,qw): "
        //           << q.x() << ", " << q.y() << ", " << q.z() << ", " << q.w() << std::endl;
    }
};
```

#### **注册观察者和设置转换**:
在 `main` 函数中实例化观察者并配置 `Tracking` 对象：

```cpp
// 在 main 函数中

// ... (加载图像等代码) ...

// 创建 SLAM 对象
ORB_SLAM3::System SLAM(argv[1], argv[2], ORB_SLAM3::System::MONOCULAR, true); // 假设argv[5]不再用于此
ORB_SLAM3::Tracking* pTracker = SLAM.GetTracker(); // 获取 Tracking 对象指针

if (!pTracker) {
    std::cerr << "错误：无法获取 Tracking 对象！" << std::endl;
    return 1;
}

// 1. 创建并注册自定义位姿观察者
MyPosePrinter posePrinter;
pTracker->RegisterPoseObserver(&posePrinter);

// 2. 定义并设置从 ORB-SLAM 世界坐标系到自定义世界坐标系的转换 T_Custom,ORB
// 假设：自定义坐标系的原点在ORB世界坐标系下的位置是 (dx, dy, dz)
// 并且自定义坐标系的轴向相对于ORB世界坐标系的轴向有一个旋转 R_Custom,ORB

// 示例：ORB-SLAM 世界坐标系的原点在自定义世界坐标系中的位置是 (1.5, 2.2, 0.0)，且无旋转。
// 这意味着，要将一个在ORB世界坐标系中的点 P_ORB 变换到自定义坐标系 P_Custom，
// 需要 P_Custom = T_Custom,ORB * P_ORB。
// 如果ORB原点在自定义坐标系中的坐标是 (tx, ty, tz)，那么从ORB坐标系到自定义坐标系的平移向量就是 (tx, ty, tz)。
Eigen::Vector3f t_custom_from_orb_translation(1.5f, 2.2f, 0.0f); // 平移向量
Sophus::SO3f R_custom_from_orb; // 旋转部分 (默认为单位旋转，即无旋转)
// 如果有特定的旋转，例如自定义坐标系的Y轴指向ORB的-Z轴，X轴指向ORB的Y轴，Z轴指向ORB的X轴
// R_custom_from_orb = Sophus::SO3f(Eigen::Matrix3f::Identity()); // 根据需要设置

Sophus::SE3f T_custom_from_orb(R_custom_from_orb, t_custom_from_orb_translation);

std::cout << "mono_euroc: 设置的 T_custom_from_orb 平移: "
          << T_custom_from_orb.translation().transpose()
          << " 旋转 (四元数 w,x,y,z): "
          << T_custom_from_orb.unit_quaternion().coeffs().transpose() << std::endl;

pTracker->SetCustomWorldTransform(T_custom_from_orb);

// ... (主跟踪循环 SLAM.TrackMonocular(im, tframe); ) ...

// 在程序结束前，可以考虑注销观察者（如果需要）
// pTracker->RegisterPoseObserver(nullptr);
```

### **逻辑**:
- **实例化与注册**: 创建 `MyPosePrinter` 的实例，并将其地址传递给 `pTracker->RegisterPoseObserver()`。
- **定义变换 $( T_{\text{Custom,ORB}} )$**:
    - 关键在于理解 `T_custom_from_orb` 的物理意义。它定义了如何将一个在 **ORB-SLAM 世界坐标系** 中的点变换到 **自定义世界坐标系** 中。
    - **平移部分 `t_custom_from_orb_translation`**: 表示 ORB-SLAM 世界坐标系的原点在自定义世界坐标系中的坐标。例如，如果 ORB 世界原点位于自定义世界的 (1.5, 2.2, 0)，那么这个平移向量就是 `(1.5, 2.2, 0)`。
    - **旋转部分 `R_custom_from_orb`**: 表示 ORB-SLAM 世界坐标系的基向量在自定义世界坐标系中的表示。如果两个坐标系轴向一致，则为单位旋转。
- **设置变换**: 调用 `pTracker->SetCustomWorldTransform(T_custom_from_orb)` 将此变换传递给 `Tracking` 对象。`Tracking` 内部会将其存储在 `mT_custom_orb` 中。
- **回调触发**: 在 `SLAM.TrackMonocular()` (或类似跟踪函数) 内部，当 `Tracking::Track()` 成功计算位姿后，它会使用存储的 `mT_custom_orb` 和当前帧位姿计算出相机在自定义坐标系下的位姿，并调用 `posePrinter.OnRealTimePoseUpdated()`。

---

通过以上修改，系统便能正确地计算并输出相机在用户定义的自定义世界坐标系下的位姿。核心在于正确理解和设置变换关系 `mT_custom_orb`。

```cpp

if (pTracker) {
    MyPosePrinter posePrinter; // 创建观察者实例

    // 定义自定义坐标系到 ORB-SLAM 世界坐标系的转换
    // 示例：自定义坐标系原点在 ORB-SLAM 世界坐标系的 (1.5, 2.2, 0)，无旋转
    Sophus::SE3f T_custom_to_orb(Sophus::SO3f(), Eigen::Vector3f(1.5f, 2.2f, 0.0f));
    // 若需旋转，可使用四元数定义：
    // Eigen::Quaternionf q(w, x, y, z);
    // Sophus::SE3f T_custom_to_orb(q.normalized().toRotationMatrix(), Eigen::Vector3f(1.5f, 2.2f, 0.0f));

    pTracker->SetCustomWorldTransform(T_custom_to_orb); // 设置坐标系转换
    pTracker->RegisterPoseObserver(&posePrinter);       // 注册观察者
}

// 后续 SLAM 处理循环...
```
### **逻辑**:
- **实例化与注册**: 创建 `MyPosePrinter` 对象并通过 `RegisterPoseObserver` 注册到 `Tracking`，使其能在位姿更新时被调用。
- **坐标系转换设置**: 
  - `T_custom_to_orb` 定义了自定义坐标系到 ORB-SLAM 世界坐标系的变换。
  - 示例中平移为 `(1.5, 2.2, 0)`，旋转为单位旋转（`SO3f()`）。若需自定义旋转，可用四元数或旋转矩阵。
- **回调执行**: 当 `Tracking` 调用 `OnRealTimePoseUpdated` 时，`MyPosePrinter` 提取 `T_custom_world_camera` 的平移部分并打印 (X, Y, Z) 位置。

---


## **总结**

### **主要修改**:
1. **定义接口**: `IPoseObserver` 提供标准化的位姿更新接收方式。
2. **集成到 `Tracking`**:
   - 添加 `RegisterPoseObserver` 注册观察者。
   - 添加 `SetCustomWorldTransform` 设置坐标系转换。
   - 在 `Track()` 中转换位姿并通知观察者。
   - 使用互斥锁确保线程安全。
   - 函数定义为 `inline` 解决链接问题。
3. **在 `mono_euroc.cc` 中使用**:
   - 实现 `MyPosePrinter` 打印位姿。
   - 配置 `T_custom_to_orb` 并注册观察者。

### **成果**:
这些更改实现了在 `mono_euroc` 示例中，实时获取相机在自定义坐标系下的位姿并输出的功能。核心位姿观察机制已正常工作，若需进一步优化图像加载路径，可另行调整。👍


